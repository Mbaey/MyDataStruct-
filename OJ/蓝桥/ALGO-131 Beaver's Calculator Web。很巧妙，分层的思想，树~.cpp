#include <bits/stdc++.h>
using namespace std;
#define _for(i,a,b) for(int i=a; i<b; i++)
#define _ufor(i,a,b) for(int i=a-1; i>=b; i--)
typedef long long ll;
const int N=5000+5,M=5000+5;

//int n,m,k, cnt=0, tmp=0;
/*
http://www.voidcn.com/article/p-fyvefixq-tk.html
思路:首先对于每个科学家我们知道他们k个问题的相对顺序不能改变,所以对于每个科学家来说他们问题本身的顺序就有可能存在坏对,由于题目中所说对于同一个科学家的问题,只要求相对顺序不变,他们可以拆开插到别的科学家的问题之间.那么我们就可以设想,我们先分别记录每个科学家本身问题顺序的坏对的最大值,那么这个最大值是否可以作为问题的最后结果呢？答案是可以的，就按照以上提到的,我们可以将其余科学家的问题按照大小顺序穿插在那个本身坏对数最大的科学家的问题之中而不产生新的坏对数.我们可以对这些问题进行分层,对于每个科学家第一次出现坏对时（如果没有坏对就是整个序列）然后进行归并排序.（这里也可以选择其他稳定的排序方法,因为每个问题的相对顺序不能改变 所以只能选择稳定的排序）一直到第sum层。。。

证明：首先对于每一个科学家自身的序列来说，由于我们用的是归并排序，所以绝对不会改变每一个科学家自身序列的相对顺序。其次对于每一层的序列，我们经过排序后肯定是保证严格递增的（即不存在坏对），对于下一层的序列来说同样如此，由于下一层的序列的问题中和上一层的序列的问题中至少存在着一个坏对，所以对于下一层的第一个数（也是最小的那个数）必定是小于上一层的最后一个数的，也就是说保证了2层之间有一个坏对数。那么最终答案就是sum个坏对数，也就是最少的坏对数。
*/
//vector<int> maps[N];
//int maps[N][N];
//int a[N][N]={0};
ll n,a,k,x,y,m,b;
struct node
{
	int x,y,z;//x 表示层数 y 表示的是所需资源单位数  z表示的是科学家的编号
}p[200010];
int cmp(node w,node l)//这里非常巧妙！如果层数相等 在同一层里我们就按照所需资源单位数排序,如果资源单位数相同就按照科学家
//编号排序,否则就按照层数排序
{
	if(w.x==l.x)
		return w.y<l.y||(w.y==l.y&&w.z<l.z);
	return w.x<l.x; 
}
int main()
{
	freopen("1.txt", "r", stdin);
	int i,j;
	int ans=-1,cnt=0;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		int t=0;//t 计算为第几层,这里都一样我们还是按照坏对来分层出现一次为一层,没有坏对就是整个序列
		scanf("%I64d %I64d %I64d %I64d %I64d",&k,&a,&x,&y,&m);	
		for(j=1;j<=k;j++)//这里是分层的关键！
		{
				p[cnt++]=(node){t,a,i};
				b=(x*a+y)%m;
				if(b<a&&j!=k)//第k个问题没有最后一个b
				t++;
				a=b;
		}
		ans=max(ans,t);
	}
	printf("%d\n",ans);
	sort(p,p+cnt,cmp);
	for(i=0;i<cnt;i++)
	{
		printf("%d %d\n",p[i].y,p[i].z);
	}
	return 0;
}

